//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Parsing\\FunctionalTreeParser.g3 2013-02-09 17:13:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using System.Numerics;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Functional.Parsing
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class FunctionalTreeParser : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CALL", "FUNC", "ID", "INT", "NEWLINE", "WS", "'%'", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "'='"
	};
	public const int EOF=-1;
	public const int CALL=4;
	public const int FUNC=5;
	public const int ID=6;
	public const int INT=7;
	public const int NEWLINE=8;
	public const int WS=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;

	public FunctionalTreeParser(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public FunctionalTreeParser(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return FunctionalTreeParser.tokenNames; } }
	public override string GrammarFileName { get { return "Parsing\\FunctionalTreeParser.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_prog();
	partial void LeaveRule_prog();
	// $ANTLR start "prog"
	// Parsing\\FunctionalTreeParser.g3:17:1: public prog : ( stat )* ;
	[GrammarRule("prog")]
	public void prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(17, 4);
		try
		{
			// Parsing\\FunctionalTreeParser.g3:17:5: ( ( stat )* )
			DebugEnterAlt(1);
			// Parsing\\FunctionalTreeParser.g3:17:9: ( stat )*
			{
			DebugLocation(17, 9);
			// Parsing\\FunctionalTreeParser.g3:17:9: ( stat )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=CALL && LA1_1<=INT)||LA1_1==10||(LA1_1>=13 && LA1_1<=17)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Parsing\\FunctionalTreeParser.g3:17:9: stat
					{
					DebugLocation(17, 9);
					PushFollow(Follow._stat_in_prog55);
					stat();
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
		}
		DebugLocation(18, 4);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return;

	}
	// $ANTLR end "prog"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();
	// $ANTLR start "stat"
	// Parsing\\FunctionalTreeParser.g3:20:1: stat : ( expr | ^( '=' ID expr ) | ^( FUNC ( . )+ ) );
	[GrammarRule("stat")]
	private void stat()
	{
		EnterRule_stat();
		EnterRule("stat", 2);
		TraceIn("stat", 2);
		CommonTree ID2 = default(CommonTree);
		BigInteger expr1 = default(BigInteger);
		BigInteger expr3 = default(BigInteger);

		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(20, 4);
		try
		{
			// Parsing\\FunctionalTreeParser.g3:20:5: ( expr | ^( '=' ID expr ) | ^( FUNC ( . )+ ) )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case CALL:
			case ID:
			case INT:
			case 10:
			case 13:
			case 14:
			case 15:
			case 16:
				{
				alt3 = 1;
				}
				break;
			case 17:
				{
				alt3 = 2;
				}
				break;
			case FUNC:
				{
				alt3 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsing\\FunctionalTreeParser.g3:20:9: expr
				{
				DebugLocation(20, 9);
				PushFollow(Follow._expr_in_stat70);
				expr1=expr();
				PopFollow();

				DebugLocation(20, 36);
				 string result = expr1.ToString();
				                                     Console.WriteLine(expr1 + " (about " + result[0] + "*10^" + (result.Length-1) + ")");
				                                   

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsing\\FunctionalTreeParser.g3:23:9: ^( '=' ID expr )
				{
				DebugLocation(23, 9);
				DebugLocation(23, 11);
				Match(input,17,Follow._17_in_stat105); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(23, 15);
				ID2=(CommonTree)Match(input,ID,Follow._ID_in_stat107); 
				DebugLocation(23, 18);
				PushFollow(Follow._expr_in_stat109);
				expr3=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(23, 36);
				 globalMemory[(ID2!=null?ID2.Text:null)] = expr3; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Parsing\\FunctionalTreeParser.g3:24:9: ^( FUNC ( . )+ )
				{
				DebugLocation(24, 9);
				DebugLocation(24, 11);
				Match(input,FUNC,Follow._FUNC_in_stat135); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(24, 16);
				// Parsing\\FunctionalTreeParser.g3:24:16: ( . )+
				int cnt2=0;
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if (((LA2_1>=CALL && LA2_1<=17)))
					{
						alt2 = 1;
					}
					else if ((LA2_1==UP))
					{
						alt2 = 2;
					}


					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Parsing\\FunctionalTreeParser.g3:24:16: .
						{
						DebugLocation(24, 16);
						MatchAny(input); 

						}
						break;

					default:
						if (cnt2 >= 1)
							goto loop2;

						EarlyExitException eee2 = new EarlyExitException( 2, input );
						DebugRecognitionException(eee2);
						throw eee2;
					}
					cnt2++;
				}
				loop2:
					;

				} finally { DebugExitSubRule(2); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stat", 2);
			LeaveRule("stat", 2);
			LeaveRule_stat();
		}
		DebugLocation(25, 4);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return;

	}
	// $ANTLR end "stat"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// Parsing\\FunctionalTreeParser.g3:27:1: expr returns [BigInteger value] : ( ^( '+' a= expr b= expr ) | ^( '-' a= expr b= expr ) | ^( '*' a= expr b= expr ) | ^( '/' a= expr b= expr ) | ^( '%' a= expr b= expr ) | ID | INT | call );
	[GrammarRule("expr")]
	private BigInteger expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
		BigInteger value = default(BigInteger);


		CommonTree ID4 = default(CommonTree);
		CommonTree INT5 = default(CommonTree);
		BigInteger a = default(BigInteger);
		BigInteger b = default(BigInteger);
		BigInteger call6 = default(BigInteger);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(27, 4);
		try
		{
			// Parsing\\FunctionalTreeParser.g3:28:5: ( ^( '+' a= expr b= expr ) | ^( '-' a= expr b= expr ) | ^( '*' a= expr b= expr ) | ^( '/' a= expr b= expr ) | ^( '%' a= expr b= expr ) | ID | INT | call )
			int alt4=8;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 14:
				{
				alt4 = 1;
				}
				break;
			case 15:
				{
				alt4 = 2;
				}
				break;
			case 13:
				{
				alt4 = 3;
				}
				break;
			case 16:
				{
				alt4 = 4;
				}
				break;
			case 10:
				{
				alt4 = 5;
				}
				break;
			case ID:
				{
				alt4 = 6;
				}
				break;
			case INT:
				{
				alt4 = 7;
				}
				break;
			case CALL:
				{
				alt4 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Parsing\\FunctionalTreeParser.g3:28:9: ^( '+' a= expr b= expr )
				{
				DebugLocation(28, 9);
				DebugLocation(28, 11);
				Match(input,14,Follow._14_in_expr179); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(28, 16);
				PushFollow(Follow._expr_in_expr183);
				a=expr();
				PopFollow();

				DebugLocation(28, 23);
				PushFollow(Follow._expr_in_expr187);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(28, 36);
				 value = a + b; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parsing\\FunctionalTreeParser.g3:29:9: ^( '-' a= expr b= expr )
				{
				DebugLocation(29, 9);
				DebugLocation(29, 11);
				Match(input,15,Follow._15_in_expr207); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(29, 16);
				PushFollow(Follow._expr_in_expr211);
				a=expr();
				PopFollow();

				DebugLocation(29, 23);
				PushFollow(Follow._expr_in_expr215);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(29, 36);
				 value = a - b; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Parsing\\FunctionalTreeParser.g3:30:9: ^( '*' a= expr b= expr )
				{
				DebugLocation(30, 9);
				DebugLocation(30, 11);
				Match(input,13,Follow._13_in_expr235); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(30, 16);
				PushFollow(Follow._expr_in_expr239);
				a=expr();
				PopFollow();

				DebugLocation(30, 23);
				PushFollow(Follow._expr_in_expr243);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(30, 36);
				 value = a * b; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Parsing\\FunctionalTreeParser.g3:31:9: ^( '/' a= expr b= expr )
				{
				DebugLocation(31, 9);
				DebugLocation(31, 11);
				Match(input,16,Follow._16_in_expr263); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(31, 16);
				PushFollow(Follow._expr_in_expr267);
				a=expr();
				PopFollow();

				DebugLocation(31, 23);
				PushFollow(Follow._expr_in_expr271);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(31, 36);
				 value = a / b; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Parsing\\FunctionalTreeParser.g3:32:9: ^( '%' a= expr b= expr )
				{
				DebugLocation(32, 9);
				DebugLocation(32, 11);
				Match(input,10,Follow._10_in_expr291); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(32, 16);
				PushFollow(Follow._expr_in_expr295);
				a=expr();
				PopFollow();

				DebugLocation(32, 23);
				PushFollow(Follow._expr_in_expr299);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(32, 36);
				 value = BigInteger.Remainder(a, b); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Parsing\\FunctionalTreeParser.g3:33:9: ID
				{
				DebugLocation(33, 9);
				ID4=(CommonTree)Match(input,ID,Follow._ID_in_expr318); 
				DebugLocation(33, 36);
				 value = this.GetValue((ID4!=null?ID4.Text:null)); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Parsing\\FunctionalTreeParser.g3:34:9: INT
				{
				DebugLocation(34, 9);
				INT5=(CommonTree)Match(input,INT,Follow._INT_in_expr354); 
				DebugLocation(34, 36);
				 value = BigInteger.Parse((INT5!=null?INT5.Text:null)); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Parsing\\FunctionalTreeParser.g3:35:9: call
				{
				DebugLocation(35, 9);
				PushFollow(Follow._call_in_expr389);
				call6=call();
				PopFollow();

				DebugLocation(35, 36);
				 value = call6; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
		}
		DebugLocation(36, 4);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return value;

	}
	// $ANTLR end "expr"

	partial void EnterRule_call();
	partial void LeaveRule_call();
	// $ANTLR start "call"
	// Parsing\\FunctionalTreeParser.g3:38:1: call returns [BigInteger value] : ^( CALL ID expr ) ;
	[GrammarRule("call")]
	private BigInteger call()
	{
		EnterRule_call();
		EnterRule("call", 4);
		TraceIn("call", 4);
		BigInteger value = default(BigInteger);


		CommonTree ID8 = default(CommonTree);
		BigInteger expr7 = default(BigInteger);

		try { DebugEnterRule(GrammarFileName, "call");
		DebugLocation(38, 4);
		try
		{
			// Parsing\\FunctionalTreeParser.g3:39:5: ( ^( CALL ID expr ) )
			DebugEnterAlt(1);
			// Parsing\\FunctionalTreeParser.g3:39:9: ^( CALL ID expr )
			{
			DebugLocation(39, 9);
			DebugLocation(39, 11);
			Match(input,CALL,Follow._CALL_in_call437); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(39, 16);
			ID8=(CommonTree)Match(input,ID,Follow._ID_in_call439); 
			DebugLocation(39, 19);
			PushFollow(Follow._expr_in_call441);
			expr7=expr();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(39, 36);
			 BigInteger p = expr7;
			                                     var funcRoot = this.FindFunction((ID8!=null?ID8.Text:null), p);
			                                     if (funcRoot == null) {
			                                         System.Console.Error.WriteLine("No match found for " + (ID8!=null?ID8.Text:null) + "(" + p + ")");
			                                     } else {
			                                         // Here we set up the local evaluator to run over the
			                                         // function definition with the parameter value.
			                                         // This re-reads a sub-AST of our input AST!
			                                         var e = new FunctionalTreeParser(funcRoot, functionDefinitions, globalMemory, p);
			                                         value = e.expr();
			                                     }
			                                   

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("call", 4);
			LeaveRule("call", 4);
			LeaveRule_call();
		}
		DebugLocation(51, 4);
		} finally { DebugExitRule(GrammarFileName, "call"); }
		return value;

	}
	// $ANTLR end "call"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stat_in_prog55 = new BitSet(new ulong[]{0x3E4F2UL});
		public static readonly BitSet _expr_in_stat70 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _17_in_stat105 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_stat107 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_stat109 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FUNC_in_stat135 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _14_in_expr179 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr183 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_expr187 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _15_in_expr207 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr211 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_expr215 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _13_in_expr235 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr239 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_expr243 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _16_in_expr263 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr267 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_expr271 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _10_in_expr291 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr295 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_expr299 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_expr318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_expr354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_expr389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_call437 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_call439 = new BitSet(new ulong[]{0x1E4D0UL});
		public static readonly BitSet _expr_in_call441 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}

} // namespace Functional.Parsing
