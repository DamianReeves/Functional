//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Parser\\Functional.g3 2013-02-09 00:24:57

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Functional.Parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class FunctionalParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CALL", "FUNC", "ID", "INT", "NEWLINE", "WS", "'%'", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "'='"
	};
	public const int EOF=-1;
	public const int CALL=4;
	public const int FUNC=5;
	public const int ID=6;
	public const int INT=7;
	public const int NEWLINE=8;
	public const int WS=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;

	public FunctionalParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public FunctionalParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return FunctionalParser.tokenNames; } }
	public override string GrammarFileName { get { return "Parser\\Functional.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_prog();
	partial void LeaveRule_prog();
	// $ANTLR start "prog"
	// Parser\\Functional.g3:22:1: public prog : ( stat )* ;
	[GrammarRule("prog")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> stat1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(22, 4);
		try
		{
			// Parser\\Functional.g3:22:5: ( ( stat )* )
			DebugEnterAlt(1);
			// Parser\\Functional.g3:22:7: ( stat )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(22, 7);
			// Parser\\Functional.g3:22:7: ( stat )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=ID && LA1_1<=NEWLINE)||LA1_1==11))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Parser\\Functional.g3:22:9: stat
					{
					DebugLocation(22, 9);
					PushFollow(Follow._stat_in_prog95);
					stat1=stat();
					PopFollow();

					adaptor.AddChild(root_0, stat1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
		}
		DebugLocation(23, 4);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();
	// $ANTLR start "stat"
	// Parser\\Functional.g3:25:1: stat : ( expr NEWLINE -> expr | ID '=' expr NEWLINE -> ^( '=' ID expr ) | func NEWLINE -> func | NEWLINE ->);
	[GrammarRule("stat")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> stat()
	{
		EnterRule_stat();
		EnterRule("stat", 2);
		TraceIn("stat", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEWLINE3 = default(CommonToken);
		CommonToken ID4 = default(CommonToken);
		CommonToken char_literal5 = default(CommonToken);
		CommonToken NEWLINE7 = default(CommonToken);
		CommonToken NEWLINE9 = default(CommonToken);
		CommonToken NEWLINE10 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr2 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> func8 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEWLINE3_tree = default(CommonTree);
		CommonTree ID4_tree = default(CommonTree);
		CommonTree char_literal5_tree = default(CommonTree);
		CommonTree NEWLINE7_tree = default(CommonTree);
		CommonTree NEWLINE9_tree = default(CommonTree);
		CommonTree NEWLINE10_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEWLINE=new RewriteRuleITokenStream(adaptor,"token NEWLINE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_func=new RewriteRuleSubtreeStream(adaptor,"rule func");
		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(25, 4);
		try
		{
			// Parser\\Functional.g3:25:5: ( expr NEWLINE -> expr | ID '=' expr NEWLINE -> ^( '=' ID expr ) | func NEWLINE -> func | NEWLINE ->)
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case INT:
			case 11:
				{
				alt2 = 1;
				}
				break;
			case ID:
				{
				switch (input.LA(2))
				{
				case 11:
					{
					switch (input.LA(3))
					{
					case INT:
						{
						int LA2_4 = input.LA(4);

						if ((LA2_4==10||(LA2_4>=13 && LA2_4<=16)))
						{
							alt2 = 1;
						}
						else if ((LA2_4==12))
						{
							int LA2_5 = input.LA(5);

							if ((LA2_5==17))
							{
								alt2 = 3;
							}
							else if ((LA2_5==NEWLINE||LA2_5==10||(LA2_5>=13 && LA2_5<=16)))
							{
								alt2 = 1;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 2, 8, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 2, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case ID:
						{
						int LA2_4 = input.LA(4);

						if (((LA2_4>=10 && LA2_4<=11)||(LA2_4>=13 && LA2_4<=16)))
						{
							alt2 = 1;
						}
						else if ((LA2_4==12))
						{
							int LA2_5 = input.LA(5);

							if ((LA2_5==17))
							{
								alt2 = 3;
							}
							else if ((LA2_5==NEWLINE||LA2_5==10||(LA2_5>=13 && LA2_5<=16)))
							{
								alt2 = 1;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 2, 8, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 2, 7, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case 11:
						{
						alt2 = 1;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 2, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					}
					break;
				case 17:
					{
					alt2 = 2;
					}
					break;
				case NEWLINE:
				case 10:
				case 13:
				case 14:
				case 15:
				case 16:
					{
					alt2 = 1;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 2, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case NEWLINE:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Parser\\Functional.g3:25:9: expr NEWLINE
				{
				DebugLocation(25, 9);
				PushFollow(Follow._expr_in_stat112);
				expr2=expr();
				PopFollow();

				stream_expr.Add(expr2.Tree);
				DebugLocation(25, 14);
				NEWLINE3=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat114);  
				stream_NEWLINE.Add(NEWLINE3);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 25:41: -> expr
				{
					DebugLocation(25, 44);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parser\\Functional.g3:26:9: ID '=' expr NEWLINE
				{
				DebugLocation(26, 9);
				ID4=(CommonToken)Match(input,ID,Follow._ID_in_stat147);  
				stream_ID.Add(ID4);

				DebugLocation(26, 12);
				char_literal5=(CommonToken)Match(input,17,Follow._17_in_stat149);  
				stream_17.Add(char_literal5);

				DebugLocation(26, 16);
				PushFollow(Follow._expr_in_stat151);
				expr6=expr();
				PopFollow();

				stream_expr.Add(expr6.Tree);
				DebugLocation(26, 21);
				NEWLINE7=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat153);  
				stream_NEWLINE.Add(NEWLINE7);



				{
				// AST REWRITE
				// elements: 17, ID, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 26:41: -> ^( '=' ID expr )
				{
					DebugLocation(26, 44);
					// Parser\\Functional.g3:26:44: ^( '=' ID expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(26, 46);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_17.NextNode(), root_1);

					DebugLocation(26, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(26, 53);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Parser\\Functional.g3:27:9: func NEWLINE
				{
				DebugLocation(27, 9);
				PushFollow(Follow._func_in_stat185);
				func8=func();
				PopFollow();

				stream_func.Add(func8.Tree);
				DebugLocation(27, 14);
				NEWLINE9=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat187);  
				stream_NEWLINE.Add(NEWLINE9);



				{
				// AST REWRITE
				// elements: func
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 27:41: -> func
				{
					DebugLocation(27, 44);
					adaptor.AddChild(root_0, stream_func.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Parser\\Functional.g3:28:9: NEWLINE
				{
				DebugLocation(28, 9);
				NEWLINE10=(CommonToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat220);  
				stream_NEWLINE.Add(NEWLINE10);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 28:41: ->
				{
					DebugLocation(29, 5);
					root_0 = null;
				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stat", 2);
			LeaveRule("stat", 2);
			LeaveRule_stat();
		}
		DebugLocation(29, 4);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return retval;

	}
	// $ANTLR end "stat"

	partial void EnterRule_func();
	partial void LeaveRule_func();
	// $ANTLR start "func"
	// Parser\\Functional.g3:31:1: func : ID '(' formalPar ')' '=' expr -> ^( FUNC ID formalPar expr ) ;
	[GrammarRule("func")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> func()
	{
		EnterRule_func();
		EnterRule("func", 3);
		TraceIn("func", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID11 = default(CommonToken);
		CommonToken char_literal12 = default(CommonToken);
		CommonToken char_literal14 = default(CommonToken);
		CommonToken char_literal15 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formalPar13 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr16 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID11_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree char_literal15_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_11=new RewriteRuleITokenStream(adaptor,"token 11");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleSubtreeStream stream_formalPar=new RewriteRuleSubtreeStream(adaptor,"rule formalPar");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "func");
		DebugLocation(31, 4);
		try
		{
			// Parser\\Functional.g3:31:5: ( ID '(' formalPar ')' '=' expr -> ^( FUNC ID formalPar expr ) )
			DebugEnterAlt(1);
			// Parser\\Functional.g3:31:9: ID '(' formalPar ')' '=' expr
			{
			DebugLocation(31, 9);
			ID11=(CommonToken)Match(input,ID,Follow._ID_in_func261);  
			stream_ID.Add(ID11);

			DebugLocation(31, 13);
			char_literal12=(CommonToken)Match(input,11,Follow._11_in_func264);  
			stream_11.Add(char_literal12);

			DebugLocation(31, 17);
			PushFollow(Follow._formalPar_in_func266);
			formalPar13=formalPar();
			PopFollow();

			stream_formalPar.Add(formalPar13.Tree);
			DebugLocation(31, 27);
			char_literal14=(CommonToken)Match(input,12,Follow._12_in_func268);  
			stream_12.Add(char_literal14);

			DebugLocation(31, 31);
			char_literal15=(CommonToken)Match(input,17,Follow._17_in_func270);  
			stream_17.Add(char_literal15);

			DebugLocation(31, 35);
			PushFollow(Follow._expr_in_func272);
			expr16=expr();
			PopFollow();

			stream_expr.Add(expr16.Tree);


			{
			// AST REWRITE
			// elements: ID, formalPar, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 31:41: -> ^( FUNC ID formalPar expr )
			{
				DebugLocation(31, 44);
				// Parser\\Functional.g3:31:44: ^( FUNC ID formalPar expr )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(31, 46);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(31, 51);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(31, 54);
				adaptor.AddChild(root_1, stream_formalPar.NextTree());
				DebugLocation(31, 64);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func", 3);
			LeaveRule("func", 3);
			LeaveRule_func();

					functionDefinitions.Add(retval.Tree);
				
		}
		DebugLocation(32, 4);
		} finally { DebugExitRule(GrammarFileName, "func"); }
		return retval;

	}
	// $ANTLR end "func"

	partial void EnterRule_formalPar();
	partial void LeaveRule_formalPar();
	// $ANTLR start "formalPar"
	// Parser\\Functional.g3:37:1: formalPar : ( ID | INT );
	[GrammarRule("formalPar")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formalPar()
	{
		EnterRule_formalPar();
		EnterRule("formalPar", 4);
		TraceIn("formalPar", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set17 = default(CommonToken);

		CommonTree set17_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "formalPar");
		DebugLocation(37, 1);
		try
		{
			// Parser\\Functional.g3:38:5: ( ID | INT )
			DebugEnterAlt(1);
			// Parser\\Functional.g3:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(38, 5);

			set17=(CommonToken)input.LT(1);
			if ((input.LA(1)>=ID && input.LA(1)<=INT))
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set17));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalPar", 4);
			LeaveRule("formalPar", 4);
			LeaveRule_formalPar();
		}
		DebugLocation(40, 1);
		} finally { DebugExitRule(GrammarFileName, "formalPar"); }
		return retval;

	}
	// $ANTLR end "formalPar"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// Parser\\Functional.g3:45:1: expr : multExpr ( ( '+' ^| '-' ^) multExpr )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 5);
		TraceIn("expr", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken char_literal19 = default(CommonToken);
		CommonToken char_literal20 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> multExpr18 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> multExpr21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree char_literal19_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(45, 4);
		try
		{
			// Parser\\Functional.g3:45:5: ( multExpr ( ( '+' ^| '-' ^) multExpr )* )
			DebugEnterAlt(1);
			// Parser\\Functional.g3:45:9: multExpr ( ( '+' ^| '-' ^) multExpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(45, 9);
			PushFollow(Follow._multExpr_in_expr330);
			multExpr18=multExpr();
			PopFollow();

			adaptor.AddChild(root_0, multExpr18.Tree);
			DebugLocation(45, 18);
			// Parser\\Functional.g3:45:18: ( ( '+' ^| '-' ^) multExpr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>=14 && LA4_1<=15)))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Parser\\Functional.g3:45:19: ( '+' ^| '-' ^) multExpr
					{
					DebugLocation(45, 19);
					// Parser\\Functional.g3:45:19: ( '+' ^| '-' ^)
					int alt3=2;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					int LA3_1 = input.LA(1);

					if ((LA3_1==14))
					{
						alt3 = 1;
					}
					else if ((LA3_1==15))
					{
						alt3 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// Parser\\Functional.g3:45:20: '+' ^
						{
						DebugLocation(45, 23);
						char_literal19=(CommonToken)Match(input,14,Follow._14_in_expr334); 
						char_literal19_tree = (CommonTree)adaptor.Create(char_literal19);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal19_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Parser\\Functional.g3:45:25: '-' ^
						{
						DebugLocation(45, 28);
						char_literal20=(CommonToken)Match(input,15,Follow._15_in_expr337); 
						char_literal20_tree = (CommonTree)adaptor.Create(char_literal20);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal20_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(45, 31);
					PushFollow(Follow._multExpr_in_expr341);
					multExpr21=multExpr();
					PopFollow();

					adaptor.AddChild(root_0, multExpr21.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 5);
			LeaveRule("expr", 5);
			LeaveRule_expr();
		}
		DebugLocation(46, 4);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_multExpr();
	partial void LeaveRule_multExpr();
	// $ANTLR start "multExpr"
	// Parser\\Functional.g3:48:1: multExpr : atom ( ( '*' | '/' | '%' ) ^ atom )* ;
	[GrammarRule("multExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> multExpr()
	{
		EnterRule_multExpr();
		EnterRule("multExpr", 6);
		TraceIn("multExpr", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set23 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> atom22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> atom24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree set23_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multExpr");
		DebugLocation(48, 4);
		try
		{
			// Parser\\Functional.g3:49:5: ( atom ( ( '*' | '/' | '%' ) ^ atom )* )
			DebugEnterAlt(1);
			// Parser\\Functional.g3:49:9: atom ( ( '*' | '/' | '%' ) ^ atom )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(49, 9);
			PushFollow(Follow._atom_in_multExpr362);
			atom22=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom22.Tree);
			DebugLocation(49, 14);
			// Parser\\Functional.g3:49:14: ( ( '*' | '/' | '%' ) ^ atom )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==10||LA5_1==13||LA5_1==16))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Parser\\Functional.g3:49:15: ( '*' | '/' | '%' ) ^ atom
					{
					DebugLocation(49, 28);

					set23=(CommonToken)input.LT(1);
					set23=(CommonToken)input.LT(1);
					if (input.LA(1)==10||input.LA(1)==13||input.LA(1)==16)
					{
						input.Consume();
						root_0 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(set23), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(49, 30);
					PushFollow(Follow._atom_in_multExpr374);
					atom24=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom24.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multExpr", 6);
			LeaveRule("multExpr", 6);
			LeaveRule_multExpr();
		}
		DebugLocation(50, 4);
		} finally { DebugExitRule(GrammarFileName, "multExpr"); }
		return retval;

	}
	// $ANTLR end "multExpr"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Parser\\Functional.g3:52:1: atom : ( INT | ID | '(' expr ')' -> expr | ID '(' expr ')' -> ^( CALL ID expr ) );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 7);
		TraceIn("atom", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken INT25 = default(CommonToken);
		CommonToken ID26 = default(CommonToken);
		CommonToken char_literal27 = default(CommonToken);
		CommonToken char_literal29 = default(CommonToken);
		CommonToken ID30 = default(CommonToken);
		CommonToken char_literal31 = default(CommonToken);
		CommonToken char_literal33 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree INT25_tree = default(CommonTree);
		CommonTree ID26_tree = default(CommonTree);
		CommonTree char_literal27_tree = default(CommonTree);
		CommonTree char_literal29_tree = default(CommonTree);
		CommonTree ID30_tree = default(CommonTree);
		CommonTree char_literal31_tree = default(CommonTree);
		CommonTree char_literal33_tree = default(CommonTree);
		RewriteRuleITokenStream stream_11=new RewriteRuleITokenStream(adaptor,"token 11");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(52, 4);
		try
		{
			// Parser\\Functional.g3:52:5: ( INT | ID | '(' expr ')' -> expr | ID '(' expr ')' -> ^( CALL ID expr ) )
			int alt6=4;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt6 = 1;
				}
				break;
			case ID:
				{
				int LA6_2 = input.LA(2);

				if ((LA6_2==11))
				{
					alt6 = 4;
				}
				else if ((LA6_2==NEWLINE||LA6_2==10||(LA6_2>=12 && LA6_2<=16)))
				{
					alt6 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 11:
				{
				alt6 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Parser\\Functional.g3:52:9: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(52, 9);
				INT25=(CommonToken)Match(input,INT,Follow._INT_in_atom390); 
				INT25_tree = (CommonTree)adaptor.Create(INT25);
				adaptor.AddChild(root_0, INT25_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Parser\\Functional.g3:53:9: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(53, 9);
				ID26=(CommonToken)Match(input,ID,Follow._ID_in_atom400); 
				ID26_tree = (CommonTree)adaptor.Create(ID26);
				adaptor.AddChild(root_0, ID26_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Parser\\Functional.g3:54:9: '(' expr ')'
				{
				DebugLocation(54, 9);
				char_literal27=(CommonToken)Match(input,11,Follow._11_in_atom410);  
				stream_11.Add(char_literal27);

				DebugLocation(54, 13);
				PushFollow(Follow._expr_in_atom412);
				expr28=expr();
				PopFollow();

				stream_expr.Add(expr28.Tree);
				DebugLocation(54, 18);
				char_literal29=(CommonToken)Match(input,12,Follow._12_in_atom414);  
				stream_12.Add(char_literal29);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 54:25: -> expr
				{
					DebugLocation(54, 28);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Parser\\Functional.g3:55:9: ID '(' expr ')'
				{
				DebugLocation(55, 9);
				ID30=(CommonToken)Match(input,ID,Follow._ID_in_atom431);  
				stream_ID.Add(ID30);

				DebugLocation(55, 12);
				char_literal31=(CommonToken)Match(input,11,Follow._11_in_atom433);  
				stream_11.Add(char_literal31);

				DebugLocation(55, 16);
				PushFollow(Follow._expr_in_atom435);
				expr32=expr();
				PopFollow();

				stream_expr.Add(expr32.Tree);
				DebugLocation(55, 21);
				char_literal33=(CommonToken)Match(input,12,Follow._12_in_atom437);  
				stream_12.Add(char_literal33);



				{
				// AST REWRITE
				// elements: ID, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 55:25: -> ^( CALL ID expr )
				{
					DebugLocation(55, 28);
					// Parser\\Functional.g3:55:28: ^( CALL ID expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(55, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CALL, "CALL"), root_1);

					DebugLocation(55, 35);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(55, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 7);
			LeaveRule("atom", 7);
			LeaveRule_atom();
		}
		DebugLocation(56, 4);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stat_in_prog95 = new BitSet(new ulong[]{0x9C2UL});
		public static readonly BitSet _expr_in_stat112 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NEWLINE_in_stat114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_stat147 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_stat149 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _expr_in_stat151 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NEWLINE_in_stat153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_in_stat185 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NEWLINE_in_stat187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_stat220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_func261 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_func264 = new BitSet(new ulong[]{0xC0UL});
		public static readonly BitSet _formalPar_in_func266 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_func268 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_func270 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _expr_in_func272 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multExpr_in_expr330 = new BitSet(new ulong[]{0xC002UL});
		public static readonly BitSet _14_in_expr334 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _15_in_expr337 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _multExpr_in_expr341 = new BitSet(new ulong[]{0xC002UL});
		public static readonly BitSet _atom_in_multExpr362 = new BitSet(new ulong[]{0x12402UL});
		public static readonly BitSet _set_in_multExpr365 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _atom_in_multExpr374 = new BitSet(new ulong[]{0x12402UL});
		public static readonly BitSet _INT_in_atom390 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom400 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _11_in_atom410 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _expr_in_atom412 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_atom414 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom431 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_atom433 = new BitSet(new ulong[]{0x8C0UL});
		public static readonly BitSet _expr_in_atom435 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_atom437 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Functional.Parser
